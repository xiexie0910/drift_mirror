================================================================================
DRIFTMIRROR - FULL STACK LEARNING PATH
================================================================================

A structured guide to understanding the codebase and how everything connects.

================================================================================
PHASE 1: UNDERSTAND THE ARCHITECTURE (30 min)
================================================================================

Start with the BIG PICTURE - trace a single feature end-to-end.

FEATURE TO TRACE: "User creates a check-in"

STEP 1: START AT THE UI
File: frontend/app/checkin/page.tsx
- What does the user see?
- What form fields exist?
- Where does the submit button send data?

STEP 2: SEE THE API CALL
File: frontend/lib/api.ts
- Find createCheckin() function
- What endpoint does it POST to?
- What's the request body structure?

STEP 3: BACKEND RECEIVES IT
File: backend/app/routes/checkins.py
- Find the @router.post("/") handler
- What does it do with the data?
- How does it save to the database?

STEP 4: SEE THE DATABASE
File: backend/app/models.py
- Find the Checkin class
- What columns exist?
- How does it relate to Resolution?

QUESTIONS TO ASK YOURSELF:
- How does data flow from form input → API → database?
- What validations happen at each layer?
- How does the backend respond back to frontend?


================================================================================
PHASE 2: UNDERSTAND EACH LAYER (1-2 hours)
================================================================================

--- FRONTEND LAYER (Next.js + TypeScript) ---

Start here: frontend/app/page.tsx (home page)

FILE EXPLORATION ORDER:
1. frontend/app/layout.tsx - Root layout, CSS setup
2. frontend/app/page.tsx - Home page logic
3. frontend/app/onboarding/page.tsx - Form handling + state management
4. frontend/components/ui/Button.tsx - How reusable components work
5. frontend/lib/api.ts - How API calls are made

CONCEPTS TO UNDERSTAND:
- How Next.js pages map to URLs
- React hooks: useState, useEffect, useRouter
- TypeScript interfaces for type safety
- API client pattern (fetch wrapper)


--- BACKEND LAYER (FastAPI + SQLAlchemy) ---

Start here: backend/app/main.py

FILE EXPLORATION ORDER:
1. backend/app/main.py - App initialization, middleware, routes
2. backend/app/db.py - Database connection setup
3. backend/app/models.py - Data models (table definitions)
4. backend/app/schemas.py - Request/response validation
5. backend/app/routes/resolutions.py - Simple CRUD operations

CONCEPTS TO UNDERSTAND:
- FastAPI decorators: @app.get(), @app.post()
- Dependency injection: Depends(get_db)
- SQLAlchemy ORM vs raw SQL
- Pydantic validation


--- THE BRIDGE: API CONTRACTS ---

KEY INSIGHT: Frontend and backend communicate via REST API

Find where they connect:
- Frontend: frontend/lib/api.ts - defines what requests to make
- Backend: backend/app/routes/ - defines what endpoints exist

EXERCISE: Pick one endpoint and trace it both ways:
Example: POST /api/checkins/
  - Frontend: api.createCheckin() (what does it send?)
  - Backend: @router.post("/") (what does it expect?)
  - Check if they match!


================================================================================
PHASE 3: UNDERSTAND THE ADVANCED FEATURES (2-3 hours)
================================================================================

THE INTERESTING PARTS - Advanced logic

--- DRIFT DETECTION ---
File: backend/app/services/drift.py
- How does it calculate drift score?
- What rules trigger a mirror?
- Look at: compute_drift_score(), should_trigger_mirror()

--- SIGNAL EXTRACTION ---
File: backend/app/services/stubs.py
- How does it extract signals from check-ins?
- Read: stub_extract_signals()
- (This is a fallback; LLM version would be in llm_client.py)

--- MIRROR COMPOSITION ---
File: backend/app/services/stubs.py
- How does it generate the mirror report?
- Look at: stub_compose_mirror()

--- PLAN ADAPTATION ---
File: backend/app/services/plan_adjuster.py
- How does the app change the plan?
- Look at: compute_plan_adjustment(), create_new_plan_version()

--- LLM INTEGRATION ---
File: backend/app/services/llm_client.py
- How does it call Ollama?
- Fallback behavior when Ollama is down?


================================================================================
PHASE 4: TRACE A COMPLETE USER FLOW (1 hour)
================================================================================

SCENARIO: User logs 3 check-ins, then views the mirror

FOLLOW THIS PATH:

1. User lands on home
   → frontend/app/page.tsx

2. User creates resolution
   → frontend/app/onboarding/page.tsx
   → calls api.createResolution()
   → backend/app/routes/resolutions.py creates in DB

3. User does check-in #1
   → frontend/app/checkin/page.tsx
   → calls api.createCheckin()
   → backend/app/routes/checkins.py saves + extracts signals

4. Repeat check-ins 2 & 3

5. On check-in #3, drift calculation triggers
   → backend/app/services/drift.py
   → should_trigger_mirror() returns true

6. Mirror composed
   → backend/app/services/stubs.py creates findings

7. Plan adjusted
   → backend/app/services/plan_adjuster.py creates new version

8. User views dashboard
   → frontend/app/dashboard/page.tsx
   → calls api.getDashboard()
   → backend/app/routes/dashboard.py returns all data

9. User clicks mirror
   → frontend/app/mirror/page.tsx displays findings

QUESTIONS TO ANSWER:
- How does each layer modify the data?
- Where are validations happening?
- How is state persisted across requests?


================================================================================
PHASE 5: UNDERSTAND THE DATA MODEL
================================================================================

Open backend/app/models.py and visualize this structure:

Resolution
  ├─ Plans (1:many)
  │   ├─ version 1
  │   └─ version 2 (after drift)
  └─ Checkins (1:many)
      ├─ Checkin #1
      │   └─ Signals (1:many)
      ├─ Checkin #2
      │   └─ Signals
      └─ Checkin #3
          └─ Signals

MirrorReport (1:1 with Resolution)
  └─ Findings (JSON array)

Feedback (relates to MirrorReport)

QUESTIONS:
- Why is this structure?
- What's the relationship between tables?
- Why use JSON for findings?


================================================================================
EXPLORATION CHECKLIST
================================================================================

Use this as you explore:

[ ] Frontend basics: Navigate through all 5 pages, understand their purpose
[ ] Component reusability: Find a Button component, see where it's used
[ ] API contracts: Pick 3 API calls, trace frontend → backend
[ ] Database flow: Create resolution → view it in database
[ ] State management: Understand useState vs props vs API calls
[ ] Error handling: What happens if API fails? (see routes)
[ ] Validation: Where does validation happen (frontend vs backend)?
[ ] LLM integration: How does Ollama get called? What's the fallback?
[ ] Business logic: Understand drift calculation formula
[ ] Complete flow: Trace "create check-in" from UI to database


================================================================================
LEARNING RESOURCES TO READ
================================================================================

FRONTEND:
- frontend/lib/api.ts - Read all type definitions
- frontend/app/onboarding/page.tsx - See form handling

BACKEND:
- backend/app/routes/checkins.py - Most complex route (signals, drift, mirror)
- backend/app/services/drift.py - The algorithm

DATABASE:
- backend/app/models.py - All table definitions


================================================================================
TIPS FOR EXPLORATION
================================================================================

1. USE SEARCH in VS Code (Cmd+F) to find imports and usages

2. HOVER OVER VARIABLES to see type hints (TypeScript helps here)

3. START SIMPLE
   - Follow a basic feature first (create resolution)
   - Then complex (mirror generation)

4. RUN THE APP
   - Make changes
   - See what breaks
   - Understand why

5. READ COMMENTS
   - Look for # and // comments explaining why

6. CHECK ERROR MESSAGES
   - When something fails, read the error carefully


================================================================================
SPECIFIC CODE PATTERNS TO STUDY
================================================================================

--- FRONTEND PATTERN: API + STATE ---

Location: frontend/app/onboarding/page.tsx

const [form, setForm] = useState({...})        // local state
const handleSubmit = async () => {
  await api.createResolution(form)             // API call
  router.push('/dashboard')                    // navigate
}

HOW IT WORKS:
1. Form state is tracked locally with useState
2. Submit handler calls API function
3. On success, navigate to new page
4. If error, stay on page and show error


--- BACKEND PATTERN: REQUEST → VALIDATE → DATABASE ---

Location: backend/app/routes/resolutions.py

@router.post("/")
async def create_resolution(data: ResolutionCreate, db: Session = Depends(get_db)):
    # 1. data is auto-validated by Pydantic
    # 2. Create ORM object
    # 3. Save to database
    # 4. Return response

HOW IT WORKS:
1. FastAPI auto-validates using ResolutionCreate schema
2. If invalid, returns 422 error
3. If valid, Depends(get_db) injects database session
4. SQLAlchemy ORM object is created
5. db.add() and db.commit() save to database
6. Response is serialized back to JSON


--- COMPLEX BUSINESS LOGIC PATTERN ---

Location: backend/app/routes/checkins.py

After saving checkin:
1. Extract signals (LLM or fallback)
2. Calculate drift
3. Check if should trigger mirror
4. If yes: compose mirror + adjust plan
5. Return everything to frontend

HOW IT WORKS:
1. Checkin is stored first
2. Signals are extracted (either from LLM or stub)
3. All checkins are queried to calculate drift
4. If drift > threshold, mirror is triggered
5. New plan version is created if drift is high
6. All results are returned in response


================================================================================
GETTING STARTED
================================================================================

RECOMMENDATION: Start with Phase 1 today
- Trace one complete feature
- Understand the flow from UI to database
- Pick a phase that interests you most
- Deep dive into that area

THEN CONTINUE WITH:
1. Phase 2 - Understand each layer separately
2. Phase 3 - Study advanced features
3. Phase 4 - Trace complete user flow
4. Phase 5 - Master the data model

TOTAL TIME: 4-5 hours to understand everything

Each phase builds on the previous one. Don't skip phases!


================================================================================
KEY FILES QUICK REFERENCE
================================================================================

FRONTEND:
- frontend/app/page.tsx - Home page
- frontend/app/onboarding/page.tsx - Create resolution
- frontend/app/checkin/page.tsx - Daily check-in
- frontend/app/dashboard/page.tsx - Dashboard/metrics
- frontend/app/mirror/page.tsx - Mirror report view
- frontend/lib/api.ts - API client
- frontend/components/ui/ - Reusable UI components

BACKEND:
- backend/app/main.py - FastAPI app setup
- backend/app/db.py - Database connection
- backend/app/models.py - SQLAlchemy models
- backend/app/schemas.py - Pydantic schemas
- backend/app/routes/resolutions.py - Resolution endpoints
- backend/app/routes/checkins.py - Check-in endpoints
- backend/app/routes/dashboard.py - Dashboard endpoints
- backend/app/services/drift.py - Drift calculation
- backend/app/services/plan_adjuster.py - Plan adjustment
- backend/app/services/llm_client.py - Ollama integration
- backend/app/services/stubs.py - Fallback logic


================================================================================
USEFUL COMMANDS
================================================================================

VIEW DATABASE:
  sqlite3 -header -column driftmirror.db "SELECT * FROM checkins;"

START BACKEND:
  cd backend
  source venv/bin/activate
  uvicorn app.main:app --reload

START FRONTEND:
  cd frontend
  npm run dev

SEARCH FOR FILES:
  Use Ctrl+Shift+P in VS Code → "Go to File" → type name

SEARCH IN FILES:
  Use Ctrl+F → search text across files

VIEW FUNCTION USAGE:
  Right-click function name → "Go to References"

================================================================================
END OF LEARNING PATH
================================================================================

Good luck exploring! This is a real, production-ready application.
Understanding it will teach you full-stack development fundamentals.

